// Copyright The Linux Foundation and each contributor to LFX.
// SPDX-License-Identifier: MIT

import { CommonModule } from '@angular/common';
import { Component, computed, DestroyRef, inject, input, OnInit, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { ButtonComponent } from '@components/button/button.component';
import { CalendarComponent } from '@components/calendar/calendar.component';
import { InputTextComponent } from '@components/input-text/input-text.component';
import { MessageComponent } from '@components/message/message.component';
import { SelectComponent } from '@components/select/select.component';
import { TextareaComponent } from '@components/textarea/textarea.component';
import { TimePickerComponent } from '@components/time-picker/time-picker.component';
import { ToggleComponent } from '@components/toggle/toggle.component';
import { GenerateAgendaRequest, MeetingTemplate } from '@lfx-one/shared';
import { TIMEZONES } from '@lfx-one/shared/constants';
import { getWeekOfMonth } from '@lfx-one/shared/utils';
import { MeetingService } from '@services/meeting.service';
import { ProjectService } from '@services/project.service';
import { MessageService } from 'primeng/api';
import { TooltipModule } from 'primeng/tooltip';
import { finalize, take, tap } from 'rxjs';

import { AgendaTemplateSelectorComponent } from '../agenda-template-selector/agenda-template-selector.component';
import { MeetingRecurrencePatternComponent } from '../meeting-recurrence-pattern/meeting-recurrence-pattern.component';

@Component({
  selector: 'lfx-meeting-details',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    ButtonComponent,
    CalendarComponent,
    InputTextComponent,
    MessageComponent,
    SelectComponent,
    TextareaComponent,
    TimePickerComponent,
    ToggleComponent,
    TooltipModule,
    AgendaTemplateSelectorComponent,
    MeetingRecurrencePatternComponent,
  ],
  templateUrl: './meeting-details.component.html',
})
export class MeetingDetailsComponent implements OnInit {
  private readonly projectService = inject(ProjectService);
  private readonly meetingService = inject(MeetingService);
  private readonly messageService = inject(MessageService);

  // Form group input from parent
  public readonly form = input.required<FormGroup>();

  // Dependency injection
  private readonly destroyRef = inject(DestroyRef);

  // AI Agenda Helper signals
  public readonly showAiHelper = signal<boolean>(false);
  public readonly isGeneratingAgenda = signal<boolean>(false);

  // Template selector signals
  public readonly showTemplateSelector = signal<boolean>(false);
  public readonly selectedTemplateId = signal<string | null>(null);

  // Custom recurrence pattern signals
  public readonly showCustomRecurrence = signal<boolean>(false);

  // Auto-title generation signals
  public readonly titleWasAutoGenerated = signal<boolean>(false);

  // Duration options for the select dropdown
  public readonly durationOptions = [
    { label: '15 minutes', value: 15 },
    { label: '30 minutes', value: 30 },
    { label: '60 minutes', value: 60 },
    { label: '90 minutes', value: 90 },
    { label: '120 minutes', value: 120 },
    { label: 'Custom...', value: 'custom' },
  ];

  // Recurrence options (dynamically updated based on selected date)
  public recurrenceOptions = signal<Array<{ label: string; value: string }>>([]);

  // Timezone options from shared constants
  public readonly timezoneOptions = TIMEZONES.map((tz) => ({
    label: `${tz.label} (${tz.offset})`,
    value: tz.value,
  }));

  // Minimum date (yesterday)
  public readonly minDate = computed(() => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    return yesterday;
  });

  public ngOnInit(): void {
    // Initialize recurrence options with current start date
    const initialStartDate = this.form().get('startDate')?.value;
    if (initialStartDate) {
      this.generateRecurrenceOptions(initialStartDate);
    } else {
      this.recurrenceOptions.set([{ label: 'Does not repeat', value: 'none' }]);
    }

    // Add custom duration validator when duration is 'custom'
    this.form()
      .get('duration')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => {
        const customDurationControl = this.form().get('customDuration');
        if (value === 'custom') {
          customDurationControl?.setValidators([Validators.required, Validators.min(5), Validators.max(480)]);
        } else {
          customDurationControl?.clearValidators();
        }
        customDurationControl?.updateValueAndValidity();
      });

    // Update recurrence pattern when start date changes
    this.form()
      .get('startDate')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((newDate) => {
        this.handleStartDateChange(newDate as Date);
      });

    // Watch for isRecurring changes to reset recurrence
    this.form()
      .get('isRecurring')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((isRecurring) => {
        if (!isRecurring) {
          this.form().get('recurrenceType')?.setValue('none');
          this.showCustomRecurrence.set(false);
        } else {
          const recurrenceType = this.form().get('recurrenceType')?.value;
          if (!recurrenceType || recurrenceType === 'none') {
            this.form().get('recurrenceType')?.setValue('weekly');
          }
        }
      });

    // Watch for recurrence value changes to show/hide custom component and set recurrence FormGroup
    this.form()
      .get('recurrenceType')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((recurrenceValue) => {
        this.showCustomRecurrence.set(recurrenceValue === 'custom');
        this.updateRecurrenceFormGroup(recurrenceValue);
      });

    // Initialize showCustomRecurrence based on current form value
    const currentRecurrence = this.form().get('recurrenceType')?.value;
    if (currentRecurrence === 'custom') {
      this.showCustomRecurrence.set(true);
    }
  }

  // AI Helper public methods
  public showAiAgendaHelper(): void {
    this.showAiHelper.set(true);
  }

  public hideAiAgendaHelper(): void {
    this.showAiHelper.set(false);
    this.form().get('aiPrompt')?.setValue('');
  }

  public async generateAiAgenda(): Promise<void> {
    const context = this.form().get('aiPrompt')?.value;
    const currentProject = this.projectService.project();
    const form = this.form();
    const title = form.get('title')?.value;
    const meetingType = form.get('meeting_type')?.value;

    if (!currentProject || !title || !meetingType || !context) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Missing Information',
        detail: 'Please fill in the meeting title, type, and prompt before generating an agenda.',
      });
      return;
    }

    const request: GenerateAgendaRequest = {
      meetingType,
      title,
      projectName: currentProject.name,
      context,
    };

    this.isGeneratingAgenda.set(true);

    this.meetingService
      .generateAgenda(request)
      .pipe(
        take(1),
        tap({
          next: (response) => {
            // Set the generated agenda in the form
            this.form().get('description')?.setValue(response.agenda);

            // Set the AI-estimated duration
            this.setEstimatedDuration(response.estimatedDuration);

            this.messageService.add({
              severity: 'success',
              summary: 'Agenda Generated',
              detail: 'AI has successfully generated a meeting agenda.',
            });
          },
          error: (error) => {
            console.error('Failed to generate agenda:', error);
            this.messageService.add({
              severity: 'error',
              summary: 'Generation Failed',
              detail: 'Failed to generate agenda. Please try again.',
            });
          },
          complete: () => {
            this.hideAiAgendaHelper();
          },
        }),
        finalize(() => {
          this.isGeneratingAgenda.set(false);
        })
      )
      .subscribe();
  }

  // Template selector public methods
  public showAgendaTemplateSelector(): void {
    this.showTemplateSelector.set(true);
  }

  public hideAgendaTemplateSelector(): void {
    this.showTemplateSelector.set(false);
    this.selectedTemplateId.set(null);
  }

  public applyTemplate(template: MeetingTemplate): void {
    this.form().get('description')?.setValue(template.content);
    this.selectedTemplateId.set(template.id);

    // Set duration based on template
    this.setEstimatedDuration(template.estimatedDuration);

    this.hideAgendaTemplateSelector();
  }

  private setEstimatedDuration(estimatedDuration: number): void {
    // Check if the estimated duration matches one of our standard options
    const standardDuration = this.durationOptions.find((option) => typeof option.value === 'number' && option.value === estimatedDuration);

    if (standardDuration) {
      // Use standard duration option
      this.form().get('duration')?.setValue(estimatedDuration);
      this.form().get('customDuration')?.setValue(null);
    } else {
      // Use custom duration
      this.form().get('duration')?.setValue('custom');
      this.form().get('customDuration')?.setValue(estimatedDuration);
    }
  }

  private generateRecurrenceOptions(date: Date): void {
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dayName = dayNames[date.getDay()];

    // Calculate which occurrence of the day in the month (1st, 2nd, 3rd, 4th, or last)
    const { weekOfMonth, isLastWeek } = getWeekOfMonth(date);
    const ordinals = ['', '1st', '2nd', '3rd', '4th'];
    const ordinal = ordinals[weekOfMonth] || `${weekOfMonth}th`;

    const options = [
      { label: 'Does not repeat', value: 'none' },
      { label: 'Daily', value: 'daily' },
      { label: `Weekly on ${dayName}`, value: 'weekly' },
      { label: 'Every weekday', value: 'weekdays' },
    ];

    // If this is the last occurrence, show "Monthly on the last [day]" instead of "Monthly on the Nth [day]"
    if (isLastWeek) {
      options.splice(4, 0, { label: `Monthly on the last ${dayName}`, value: 'monthly_last' });
    } else {
      options.splice(4, 0, { label: `Monthly on the ${ordinal} ${dayName}`, value: 'monthly_nth' });
    }

    // Add custom option at the end
    options.push({ label: 'Custom...', value: 'custom' });

    this.recurrenceOptions.set(options);
  }

  private handleStartDateChange(newDate: Date): void {
    const currentRecurrenceType = this.form().get('recurrenceType')?.value;

    // Always regenerate options for the new date
    this.generateRecurrenceOptions(newDate);

    if (!currentRecurrenceType || currentRecurrenceType === 'none') {
      // No recurrence set, nothing to update
      return;
    }

    // Update recurrence patterns based on type
    switch (currentRecurrenceType) {
      case 'weekly':
        // Update simple weekly pattern to new day
        this.updateSimpleWeeklyPattern(newDate);
        break;

      case 'monthly_nth':
      case 'monthly_last':
        // Update monthly pattern based on new date position
        this.updateMonthlyPattern(newDate, currentRecurrenceType);
        break;
      // Other pattern will be handled by the recurrence pattern component
    }
  }

  private updateSimpleWeeklyPattern(newDate: Date): void {
    const recurrenceFormGroup = this.form().get('recurrence');
    if (recurrenceFormGroup) {
      recurrenceFormGroup.patchValue({
        weekly_days: String(newDate.getDay() + 1), // Convert 0-6 to 1-7
      });
    }
  }

  private updateMonthlyPattern(newDate: Date, recurrenceType: string): void {
    const { weekOfMonth, isLastWeek } = getWeekOfMonth(newDate);
    const recurrenceFormGroup = this.form().get('recurrence');

    if (recurrenceFormGroup) {
      // Update the recurrence type if it changed from nth to last or vice versa
      if ((recurrenceType === 'monthly_nth' && isLastWeek) || (recurrenceType === 'monthly_last' && !isLastWeek)) {
        this.form()
          .get('recurrenceType')
          ?.setValue(isLastWeek ? 'monthly_last' : 'monthly_nth');
      }

      recurrenceFormGroup.patchValue({
        monthly_week: isLastWeek ? -1 : weekOfMonth,
        monthly_week_day: newDate.getDay() + 1, // Convert 0-6 to 1-7
      });
    }
  }

  private updateRecurrenceFormGroup(recurrenceType: string): void {
    const recurrenceFormGroup = this.form().get('recurrence');
    if (!recurrenceFormGroup) return;

    const startDate = this.form().get('startDate')?.value as Date;

    // Reset the recurrence FormGroup
    recurrenceFormGroup.patchValue({
      type: null,
      repeat_interval: 0,
      weekly_days: null,
      monthly_day: null,
      monthly_week: null,
      monthly_week_day: null,
      end_date_time: null,
      end_times: null,
    });

    switch (recurrenceType) {
      case 'none':
        // For none, keep repeat_interval as 0
        break;

      case 'daily':
        recurrenceFormGroup.patchValue({
          type: 1, // Daily
          repeat_interval: 1,
        });
        break;

      case 'weekly':
        recurrenceFormGroup.patchValue({
          type: 2, // Weekly
          repeat_interval: 1,
          weekly_days: String(startDate.getDay() + 1), // Convert 0-6 to 1-7
        });
        break;

      case 'weekdays':
        recurrenceFormGroup.patchValue({
          type: 2, // Weekly
          repeat_interval: 1,
          weekly_days: '2,3,4,5,6', // Monday to Friday
        });
        break;

      case 'monthly_nth':
      case 'monthly_last': {
        const { weekOfMonth, isLastWeek } = getWeekOfMonth(startDate);
        recurrenceFormGroup.patchValue({
          type: 3, // Monthly
          repeat_interval: 1,
          monthly_week: isLastWeek ? -1 : weekOfMonth,
          monthly_week_day: startDate.getDay() + 1, // Convert 0-6 to 1-7
        });
        break;
      }

      case 'custom':
        // For custom, the recurrence pattern component will handle the values
        break;
    }
  }
}
