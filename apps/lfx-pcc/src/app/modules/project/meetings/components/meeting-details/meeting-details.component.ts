// Copyright The Linux Foundation and each contributor to LFX.
// SPDX-License-Identifier: MIT

import { CommonModule } from '@angular/common';
import { Component, computed, DestroyRef, inject, input, OnInit, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { ButtonComponent } from '@components/button/button.component';
import { CalendarComponent } from '@components/calendar/calendar.component';
import { InputTextComponent } from '@components/input-text/input-text.component';
import { SelectComponent } from '@components/select/select.component';
import { TextareaComponent } from '@components/textarea/textarea.component';
import { TimePickerComponent } from '@components/time-picker/time-picker.component';
import { ToggleComponent } from '@components/toggle/toggle.component';
import { GenerateAgendaRequest, MeetingTemplate } from '@lfx-pcc/shared';
import { TIMEZONES } from '@lfx-pcc/shared/constants';
import { MeetingService } from '@services/meeting.service';
import { ProjectService } from '@services/project.service';
import { MessageService } from 'primeng/api';
import { TooltipModule } from 'primeng/tooltip';
import { finalize, take, tap } from 'rxjs';

import { AgendaTemplateSelectorComponent } from '../agenda-template-selector/agenda-template-selector.component';

@Component({
  selector: 'lfx-meeting-details',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    ButtonComponent,
    CalendarComponent,
    InputTextComponent,
    SelectComponent,
    TextareaComponent,
    TimePickerComponent,
    ToggleComponent,
    TooltipModule,
    AgendaTemplateSelectorComponent,
  ],
  templateUrl: './meeting-details.component.html',
})
export class MeetingDetailsComponent implements OnInit {
  private readonly projectService = inject(ProjectService);
  private readonly meetingService = inject(MeetingService);
  private readonly messageService = inject(MessageService);

  // Form group input from parent
  public readonly form = input.required<FormGroup>();

  // Dependency injection
  private readonly destroyRef = inject(DestroyRef);

  // AI Agenda Helper signals
  public readonly showAiHelper = signal<boolean>(false);
  public readonly isGeneratingAgenda = signal<boolean>(false);

  // Template selector signals
  public readonly showTemplateSelector = signal<boolean>(false);
  public readonly selectedTemplateId = signal<string | null>(null);

  // Auto-title generation signals
  public readonly titleWasAutoGenerated = signal<boolean>(false);

  // Duration options for the select dropdown
  public readonly durationOptions = [
    { label: '15 minutes', value: 15 },
    { label: '30 minutes', value: 30 },
    { label: '60 minutes', value: 60 },
    { label: '90 minutes', value: 90 },
    { label: '120 minutes', value: 120 },
    { label: 'Custom...', value: 'custom' },
  ];

  // Recurrence options (dynamically updated based on selected date)
  public recurrenceOptions = signal<Array<{ label: string; value: string }>>([]);

  // Timezone options from shared constants
  public readonly timezoneOptions = TIMEZONES.map((tz) => ({
    label: `${tz.label} (${tz.offset})`,
    value: tz.value,
  }));

  // Minimum date (yesterday)
  public readonly minDate = computed(() => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    return yesterday;
  });

  public ngOnInit(): void {
    // Initialize recurrence options with current start date
    const initialStartDate = this.form().get('startDate')?.value;
    if (initialStartDate) {
      this.generateRecurrenceOptions(initialStartDate);
    } else {
      this.recurrenceOptions.set([{ label: 'Does not repeat', value: 'none' }]);
    }

    // Add custom duration validator when duration is 'custom'
    this.form()
      .get('duration')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => {
        const customDurationControl = this.form().get('customDuration');
        if (value === 'custom') {
          customDurationControl?.setValidators([Validators.required, Validators.min(5), Validators.max(480)]);
        } else {
          customDurationControl?.clearValidators();
        }
        customDurationControl?.updateValueAndValidity();
      });

    // Reset recurrence selection when start date changes
    this.form()
      .get('startDate')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => {
        // Reset recurrence to 'none' when date changes to avoid confusion
        this.form().get('recurrence')?.setValue('none');
        this.generateRecurrenceOptions(value as Date);
      });

    // Watch for isRecurring changes to reset recurrence
    this.form()
      .get('isRecurring')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((isRecurring) => {
        if (!isRecurring) {
          this.form().get('recurrence')?.setValue('none');
        } else {
          const recurrence = this.form().get('recurrence')?.value;
          if (!recurrence || recurrence === 'none') {
            this.form().get('recurrence')?.setValue('weekly');
          }
        }
      });
  }

  // AI Helper public methods
  public showAiAgendaHelper(): void {
    this.showAiHelper.set(true);
  }

  public hideAiAgendaHelper(): void {
    this.showAiHelper.set(false);
    this.form().get('aiPrompt')?.setValue('');
  }

  public async generateAiAgenda(): Promise<void> {
    const context = this.form().get('aiPrompt')?.value;
    const currentProject = this.projectService.project();
    const form = this.form();
    const title = form.get('title')?.value;
    const meetingType = form.get('meeting_type')?.value;

    if (!currentProject || !title || !meetingType || !context) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Missing Information',
        detail: 'Please fill in the meeting title, type, and prompt before generating an agenda.',
      });
      return;
    }

    const request: GenerateAgendaRequest = {
      meetingType,
      title,
      projectName: currentProject.name,
      context,
    };

    this.isGeneratingAgenda.set(true);

    this.meetingService
      .generateAgenda(request)
      .pipe(
        take(1),
        tap({
          next: (response) => {
            // Set the generated agenda in the form
            this.form().get('description')?.setValue(response.agenda);

            // Set the AI-estimated duration
            this.setAiEstimatedDuration(response.estimatedDuration);

            this.messageService.add({
              severity: 'success',
              summary: 'Agenda Generated',
              detail: 'AI has successfully generated a meeting agenda.',
            });
          },
          error: (error) => {
            console.error('Failed to generate agenda:', error);
            this.messageService.add({
              severity: 'error',
              summary: 'Generation Failed',
              detail: 'Failed to generate agenda. Please try again.',
            });
          },
          complete: () => {
            this.hideAiAgendaHelper();
          },
        }),
        finalize(() => {
          this.isGeneratingAgenda.set(false);
        })
      )
      .subscribe();
  }

  // Template selector public methods
  public showAgendaTemplateSelector(): void {
    this.showTemplateSelector.set(true);
  }

  public hideAgendaTemplateSelector(): void {
    this.showTemplateSelector.set(false);
    this.selectedTemplateId.set(null);
  }

  public applyTemplate(template: MeetingTemplate): void {
    this.form().get('description')?.setValue(template.content);
    this.selectedTemplateId.set(template.id);

    // Set duration based on template
    this.setTemplateDuration(template.estimatedDuration);

    this.hideAgendaTemplateSelector();
  }

  private setTemplateDuration(estimatedDuration: number): void {
    // Check if the estimated duration matches one of our standard options
    const standardDuration = this.durationOptions.find((option) => typeof option.value === 'number' && option.value === estimatedDuration);

    if (standardDuration) {
      // Use standard duration option
      this.form().get('duration')?.setValue(estimatedDuration);
      this.form().get('customDuration')?.setValue(null);
    } else {
      // Use custom duration
      this.form().get('duration')?.setValue('custom');
      this.form().get('customDuration')?.setValue(estimatedDuration);
    }
  }

  private generateRecurrenceOptions(date: Date): void {
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dayName = dayNames[date.getDay()];

    // Calculate which occurrence of the day in the month (1st, 2nd, 3rd, 4th, or last)
    const { weekOfMonth, isLastWeek } = this.getWeekOfMonth(date);
    const ordinals = ['', '1st', '2nd', '3rd', '4th'];
    const ordinal = ordinals[weekOfMonth] || `${weekOfMonth}th`;

    const options = [
      { label: 'Daily', value: 'daily' },
      { label: `Weekly on ${dayName}`, value: 'weekly' },
      { label: 'Every weekday', value: 'weekdays' },
    ];

    // If this is the last occurrence, show "Monthly on the last [day]" instead of "Monthly on the Nth [day]"
    if (isLastWeek) {
      options.splice(3, 0, { label: `Monthly on the last ${dayName}`, value: 'monthly_last' });
    } else {
      options.splice(3, 0, { label: `Monthly on the ${ordinal} ${dayName}`, value: 'monthly_nth' });
    }

    this.recurrenceOptions.set(options);
  }

  private getWeekOfMonth(date: Date): { weekOfMonth: number; isLastWeek: boolean } {
    // Find the first occurrence of this day of week in the month
    const targetDayOfWeek = date.getDay();
    let firstOccurrence = 1;
    while (new Date(date.getFullYear(), date.getMonth(), firstOccurrence).getDay() !== targetDayOfWeek) {
      firstOccurrence++;
    }

    // Calculate which week this date is in
    const weekOfMonth = Math.floor((date.getDate() - firstOccurrence) / 7) + 1;

    // Check if this is the last occurrence of this day in the month
    const nextWeekDate = new Date(date.getTime() + 7 * 24 * 60 * 60 * 1000);
    const isLastWeek = nextWeekDate.getMonth() !== date.getMonth();

    return { weekOfMonth, isLastWeek };
  }

  private setAiEstimatedDuration(estimatedDuration: number): void {
    // Check if the estimated duration matches one of our standard options
    const standardDuration = this.durationOptions.find((option) => typeof option.value === 'number' && option.value === estimatedDuration);

    if (standardDuration) {
      // Use standard duration option
      this.form().get('duration')?.setValue(estimatedDuration);
      this.form().get('customDuration')?.setValue(null);
    } else {
      // Use custom duration
      this.form().get('duration')?.setValue('custom');
      this.form().get('customDuration')?.setValue(estimatedDuration);
    }
  }
}
